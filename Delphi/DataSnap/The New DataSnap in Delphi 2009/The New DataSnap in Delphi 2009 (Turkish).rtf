{\rtf1\ansi\ansicpg1254\deff0\deflang1055{\fonttbl{\f0\fnil\fcharset238{\*\fname Courier New;}Courier New CE;}{\f1\fnil\fcharset162 Verdana;}{\f2\fnil\fcharset162{\*\fname Courier New;}Courier New TUR;}{\f3\fnil MS Sans Serif;}{\f4\fnil\fcharset2 Symbol;}}
{\colortbl ;\red96\green96\blue96;}
{\*\generator Msftedit 5.41.21.2509;}\viewkind4\uc1\pard\cf1\lang1033\f0\fs32\par
\b === Programlama ve Tasar\u305?m ===\par
\b0\par
\fs24\par
\ul\b --- The New Datasnap in Delphi 2009 ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20 COM Aray\'fcz'\'fc kullanarak Delphi'de \'c7ok Katmanl\'fd Uygulamalar Geli\'fetirmek\par
\par
\cf1\lang1033\f0\fs24\par
\ul\b --- Giri\'ba ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab Delphi, uzun zamand\'fdr \'e7ok katmanl\'fd veritaban\'fd uygulamalar\'fd geli\'fetirmek i\'e7in bir teknoloji sunuyordu. DCOM teknolojisinin yerine, uzaktan ba\'f0lant\'fdy\'fd soketler veya HTTP ile sa\'f0layan, COM'a dayanan bu yap\'fd eskiden M\'ddDAS, \'feu anda ise DATASNAP olarak bilinmektedir.Bir ara SOAP ba\'f0lant\'fds\'fdn\'fd destekleyen \'e7ok az de\'f0i\'fetirilmi\'fe bir versiyonu olan CORBA teknolojisini desteklediler.\par
\tab Delphi 2009, klasik datasnap yap\'fds\'fdn\'fd destekledi\'f0i gibi yeni bir uzaktan y\'f6netim ve \'e7ok katman teknolojisini desteklemektedir. Bu teknoloji, dbExpress mimarisine dayanmaktad\'fdr.Bu teknolojinin ad\'fd da datasnap'tir ama kavram karma\'feas\'fdna yol a\'e7mamak i\'e7in "DataSnap 2009" olarak adland\'fdr\'fdlmaktad\'fdr.\par
\cf1\lang1033\f0\fs24\par
\ul\b --- DataSnap 2009 Demosu Olu\'baturmak ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab\'c7ok fazla detay\'fdn i\'e7ine girmeden \'f6nce, basit 3 katmanl\'fd veritaban\'fd demosu ile ba\'felayaca\'f0\'fdm. Bu, birka\'e7 noktay\'fd a\'e7\'fd\'f0a kavu\'feturacak ve bir \'f6nceki versiyonla aras\'fdndaki farklar\'fd g\'f6stermemizi sa\'f0layacakt\'fdr.\par
\cf1\lang1033\f0\fs24\par
\ul\b --- Sunucu Olu\'baturmak ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab\'ddlk ad\'fdm, DataSnap 2009 sunucu uygulamas\'fd olu\'feturmakt\'fdr. Bu, i\'e7ine bir sunucu mod\'fcl\'fc eklemek i\'e7in standart bir VCl uygulamas\'fd da olabilir (Sunucu Mod\'fcl\'fc, Yeni Eleman Ekleme (New \'ddtem) diyalog kutusu i\'e7erisinde Delphi Dosyalar\'fd (Delphi Files) b\'f6l\'fcm\'fcnde bulunur, \'c7ok Katmanl\'fd (Multi-Tier) b\'f6l\'fcm\'fcnde de\'f0il)\par
\tab Sunucu Mod\'fcl\'fcn i\'e7erisine (standart bir veri mod\'fcl\'fc (data module) de eklenebilir asl\'fdnda) veritaban\'fd sunucusuna ba\'f0lanmak i\'e7in genelde dbExpress bile\'feenleri (component) ve ek olarak belirlenen verisetlerini g\'f6stermek i\'e7in bir veri seti sa\'f0lay\'fdc\'fds\'fd bile\'feeni (dataset provider) eklenmelidir\par
\par
\tab object IBCONNECTION: TSQLConnection \par
\pard\li480   \tab\tab ConnectionName = 'IBCONNECTION' \par
\pard\tab   \tab DriverName = 'Interbase' \par
  \tab\tab LoginPrompt = False \par
\tab   \tab Params.Strings = ( \par
    \tab\tab 'DriverName=Interbase' \par
\tab     \tab 'Database=C:\\Program Files\\...\\Data\\Employee.GDB') \par
\tab end \par
\tab object EMPLOYEE: TSQLDataSet \par
  \tab\tab CommandText = 'EMPLOYEE' \par
\tab   \tab CommandType = ctTable \par
\tab   \tab SQLConnection = IBCONNECTION \par
\tab end \par
\tab object DataSetProviderEmployee: TDataSetProvider \par
  \tab\tab DataSet = EMPLOYEE \par
\tab end \par
\par
\tab Sunucu mod\'fcl\'fc, daha \'f6nce yap\'fdlana \'e7ok benzer bir \'feekilde kuruldu. Peki COM deste\'f0i i\'e7erisindeki (tamamen gitmi\'fe)  konfig\'fcrasyon ve ba\'f0lant\'fd deste\'f0i i\'e7in ihtiyac\'fdm\'fdz olan 3 adet bile\'feen nerede? Bu 3 bile\'feen de \'feunlard\'fdr;\par
\par
\tab\b DSServer\b0 : B\'fct\'fcn DataSnap bile\'feenlerini bir arada tutarak ileti\'feimini sa\'f0layan, ana sunucu konfig\'fcrasyon bile\'feenidir.\par
\tab\b DSServerClass: \b0 Her s\'fdn\'fdf i\'e7in o s\'fdn\'fdf\'fd sergilemeye yarayan bile\'feendir.Bu bile\'feen, bir s\'fdn\'fdf\'fd eri\'feilebilir hale getirmez, ama bir s\'fdn\'fdf fabrikas\'fd (class factory) gibi s\'fdn\'fdf\'fdn nesnelerini, uzaktan bir istemcinin \'e7a\'f0\'fdrmak isteyece\'f0i nesneleri olu\'feturabilir.Bir di\'f0er deyi\'fele s\'fdn\'fdf\'fdn public olarak tabir edilen par\'e7alar\'fdn\'fd g\'f6sterir.\par
\tab\b DSTCPServerTransport\b0 : Kullan\'fdlacak ta\'fe\'fdma protokol\'fcn\'fc ve konfig\'fcrasyonunu ayarlamaya yarayan bir bile\'feendir. (Delphi 2009 i\'e7in direkt eri\'feim sa\'f0lanabilecek tek bir protokol vard\'fdr.). \'d6rnek olarak hangi TCP/IP portunun kullan\'fdlaca\'f0\'fd verilebilir.\par
\par
\tab Demoda bu bile\'feenler sunucunun ana formundad\'fdr, \'feu \'feekilde konfig\'fcre edilebilir.\par
\par
\tab object DSServer1: TDSServer \par
  \tab\tab AutoStart = True \par
\tab\tab HideDSAdmin = False \par
\tab\tab OnConnect = DSServer1Connect \par
  \tab\tab OnDisconnect = DSServer1Disconnect \par
\tab end \par
\tab object DSTCPServerTransport1: TDSTCPServerTransport \par
  \tab\tab PoolSize = 0 \par
  \tab\tab Server = DSServer1 \par
  \tab\tab BufferKBSize = 32 \par
\tab end \par
\tab object DSServerClass1: TDSServerClass \par
  \tab\tab OnGetClass = DSServerClass1GetClass \par
  \tab\tab Server = DSServer1 \par
  \tab\tab LifeCycle = 'Session' \par
\tab end\par
\par
\tab Bu \'f6zelliklerin baz\'fd detaylar\'fdna ilerde de\'f0inece\'f0iz. Yukar\'fdda TCP/IP portunun de\'f0erinin g\'f6rememenizin sebebi, varsay\'fdlan (default) de\'f0er olan 211 \'fczerinde herhangi bir de\'f0i\'feiklik yapmad\'fd\'f0\'fdmdand\'fdr. \'deu anda yazmam\'fdz gereken tek Delphi kodu, sa\'f0lay\'fdc\'fdlar\'fd sergileyen sunucu mod\'fcl\'fcne ba\'f0lanacak DSServerClass1 bile\'feenine ba\'f0lanmak i\'e7in s\'fdn\'fdf fabrikas\'fd kodunu yazmakt\'fdr.\par
\par
\tab procedure TFormFirst3Tier2009Server. \par
  \tab\tab DSServerClass1GetClass(DSServerClass: TDSServerClass; \par
  \tab\tab var PersistentClass: TPersistentClass); \par
\tab begin \par
  \tab\tab PersistentClass := TDSFirst3TierServerModule; \par
\tab end;  \b\tab\par
\par
\tab\b0 Sunucu i\'e7in gerekli olan kod kesimi sadece bu kadar. \'dcst taraftaki kod, DSServer bile\'feeninin olaylar\'fd olan OnConnect ve OnDisconnect (ba\'f0lanma ve ba\'f0lant\'fd kesilmesi) olay tutulmas\'fd (event handle) i\'e7in bir loglama deyimi yaz\'fdlm\'fd\'fet\'fdr.\par
\tab Tekrar belirtiyorum ki, her hangi bir yoldan \'fcye olmaya (register) gerek yok. Basit\'e7e Delphi IDE'sindeki \'c7al\'fd\'fet\'fdr/Debug Etmeden \'c7al\'fd\'fet\'fdr (Run/Run Without Debugging) \'f6zelliklerinden herhangi biri se\'e7ilerek basit\'e7e \'e7al\'fd\'fet\'fdr\'fdlabilir. Ayr\'fdca istemci taraf\'fd in\'fea edilebilir ve tasar\'fdm zamanl\'fd (design time) olarak istemci , sunucuya ba\'f0lanabilir.\b\tab\b0\par
\par
\par
\cf1\lang1033\f0\fs24\par
\ul\b --- \lang1055\f2\'dd\lang1033\f0 lk \lang1055\f2\'dd\lang1033\f0 stemci ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab\'deu anda eri\'feilebilir bir sunucumuz oldu\'f0una g\'f6re ilk istemcimizi olu\'feturabiliriz. DataSnap 2009 istemci uygulamas\'fdnda yeni DataSnap dbExpress s\'fcr\'fcc\'fcs\'fc ile birle\'feebilecek bir SQLConnection (SQL Ba\'f0lant\'fd) bile\'feeni kullanmal\'fd ve bunu uygun TCP/IP portu ile konfig\'fcre etmeliyiz.\par
\tab Sonras\'fdnda ServerClassName \'f6zelli\'f0i ile sunucu s\'fdn\'fdfa (server class) adres g\'f6sterecek bir DSComponentProvider bile\'feeni kullanmal\'fdy\'fdz. Bu sunucudaki arac\'fd bir s\'fdn\'fdf fabrikas\'fd de\'f0ildir(DSServerClass1), ama s\'fdn\'fdf fabrikas\'fdn\'fdn esas hedefidir. Benim \'f6rne\'f0imde bu TDSFirst3TierServerModule s\'fdn\'fdf\'fdd\'fdr.\par
\tab Geleneksel bir DataSnap uygulamas\'fdnda oldu\'f0u gibi, ClientDataSet (istemci veri seti) bile\'feeni veri setine (dataset) gidip gelme, g\'fcncelleme ve uzaktan eri\'feim i\'e7in sa\'f0lay\'fdc\'fdy\'fd kullan\'fdr. \'d6ncelikle ClientDataSet'in RemoteServer \'f6zelli\'f0ine, s\'fcr\'fckle-b\'fdrak listesindeki (drop-down) DSProviderConnection1 bile\'feenini s\'fcrekleyip b\'fdrakarak atama yapar\'fdz. Sonra ProviderName \'f6zelli\'f0ine, DataSetProviderEmployee sa\'f0lay\'fdc\'fds\'fdn\'fd gene s\'fcr\'fckle b\'fdraktan eri\'feerek atar\'fdz ki uzaktaki veri mod\'fcl\'fcnde b\'fct\'fcn \'e7\'fdkar\'fdlm\'fd\'fe DataSetProvider bile\'feenlerini dolduran bir sa\'f0lay\'fdc\'fdd\'fdr.\par
\tab A\'fea\'f0\'fddaki kod par\'e7as\'fd yukar\'fdda bahsetti\'f0imiz bile\'feenlerin \'f6zelliklerini anlatan ayr\'fdca bir veri kayna\'f0\'fd (DataSource) bile\'feeni, ki veritaban\'fdndaki bir tabloyu bir DBGrid i\'e7erisinde g\'f6stermek i\'e7in kullan\'fdl\'fdr, i\'e7eren bir kod par\'e7as\'fdd\'fdr.\par
\par
\tab object SQLConnection1: TSQLConnection \par
  \tab\tab DriverName = 'Datasnap' \par
\tab end \par
\tab object DSProviderConnection1: TDSProviderConnection \par
  \tab\tab ServerClassName = 'TDSFirst3TierServerModule' \par
  \tab\tab SQLConnection = SQLConnection1 \par
\tab end \par
\tab object ClientDataSet1: TClientDataSet \par
  \tab\tab ProviderName = 'DataSetProviderEmployee' \par
  \tab\tab RemoteServer = DSProviderConnection1\par
\tab end \par
\tab object DataSource1: TDataSource \par
  \tab\tab DataSet = ClientDataSet1 \par
\tab end  \par
\par
\tab Tan\'fdt\'fdc\'fd bir demoyu olu\'feturacak her \'feey buradad\'fdr. E\'f0er \'f6nce sunucuyu sonra istemciyi \'e7al\'fd\'fet\'fdrarak a\'e7ma ile ilgili butona t\'fdklad\'fd\'f0\'fdm\'fdz zaman veritaban\'fd i\'e7erisindeki veriyi g\'f6rebilirsiniz. Ayr\'fdca sunucu taraf\'fdndan \'fcretilen log da g\'f6r\'fclebilmektedir.\par
\cf1\lang1033\f0\fs24\par
\ul\b --- DataSnap'tan DataSnap 2009'a ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab Geleneksel DataSnap uygulamalar\'fd ile kar\'fe\'fdla\'fet\'fdr\'fdld\'fd\'f0\'fdnda, birka\'e7 \'f6nemli fark bulunmaktad\'fdr. Mimari ve da\'f0\'fdt\'fdm ile daha \'e7ok ili\'fekili olarak esas kod \'fczerinde \'feunlar yaz\'fdlmal\'fdd\'fdr.\par
\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-200\li920 Sunucu geli\'fetirmek i\'e7in COM'a ihtiya\'e7 bulunmamaktad\'fdr. E\'f0er kullan\'fdc\'fd, ge\'e7mi\'feteki soketleri kullanmak istiyorsa, bunun i\'e7in sunucu taraf\'fdnda soketten COM'a (socket-to-COM) haritalama servisi bulunmal\'fdd\'fdr. \'deu anda sunucu ve istemci uygulamalar direkt TCP/IP \'fczerinden ileti\'feim kurabilmektedir.\par
{\pntext\f4\'B7\tab}Yan etki olarak, sunucuya \'fcye olmak zorunda de\'f0iliz, ayr\'fdca yard\'fdmc\'fd bir servis \'e7al\'fd\'fet\'fdrmak zorunda da de\'f0iliz. Sunucunun sa\'f0lamas\'fd gereken tek \'feey, istemcinin eri\'feebilmesi i\'e7in a\'e7\'fdk bir TCP/IP portudur.\par
{\pntext\f4\'B7\tab}Sunucu taraf\'fdndaki uygulamay\'fd bir kere elle (manuel) \'e7al\'fd\'fet\'fdrmak zorunday\'fdz, ya da bunu i\'e7in bir servis olu\'feturulmal\'fd. Eskiden COM deste\'f0i, ihtiya\'e7 duyuldu\'f0unda sunucu uygulamas\'fdn\'fdn \'e7al\'fd\'feaca\'f0\'fdn\'fd i\'fearet ediyordu.\par
{\pntext\f4\'B7\tab}Bile\'feenler a\'e7\'fds\'fdndan sunucunun hayata ge\'e7irilmesi biraz daha karma\'fe\'fdkt\'fdr ama COM meslekta\'fe\'fdna g\'f6re arka planda \'e7ok daha az kod yazarak i\'felemler halledilir.\par
{\pntext\f4\'B7\tab}\'ddstemcinin uygulamaya konmas\'fd da ayn\'fd \'feekilde \'f6zde\'fetir. Sadce ihtiyac\'fdm\'fdz olan \'f6zel bir ba\'f0lant\'fd bile\'feeni yerine standart bir SQLConnection bile\'feenidir.\par
{\pntext\f4\'B7\tab}Sunucu taraf\'fdnda, TDSServerModule, TDataModule bile\'feeninden IAppServer aray\'fcz\'fcn\'fc i\'e7erecek \'feekilde (daha \'f6nceden COM tabanl\'fd TRemoteDataModule taraf\'fdndan da kullan\'fdlan aray\'fcz) ve $MethodInfo derleyici direktifine olanak sa\'f0layacak \'feekilde kal\'fdt\'fdm yapar\par
{\pntext\f4\'B7\tab}\'ddstemci taraf\'fdndaki dbExpress s\'fcr\'fcc\'fcs\'fc, %100 saf Delphi s\'fcr\'fcc\'fcs\'fc oldu\'f0undan, ba\'f0lant\'fd i\'e7in dbExpress kullan\'fdlsa bile istemci taraf\'fdnda her hangi bir .dll dosyas\'fd olu\'feturmaya gerek yoktur.\par
\pard\li720\par
\pard\tab Sunucu uygulamay\'fd kapat\'fdrken son derece dikkatli olmak gerekir. COM mimarisine ters olarak, COM bekleyen ba\'f0lant\'fd talepleri i\'e7in uyar\'fd verir, DataSnap 2009 sunucusu e\'f0er \'fczerinde herhangi bir ba\'f0lant\'fd kalmam\'fd\'fesa kapan\'fdr. Buna ra\'f0meni ana form gitse bile, b\'fct\'fcn ba\'f0lant\'fdlar kapanm\'fd\'fe olsa bile bellekte yer kaplamaya devam eder. Sunucu uygulamas\'fdn\'fd kapatmak i\'e7in G\'f6rev Y\'f6neticisini \'e7al\'fd\'fet\'fdrmak veya \'dd\'felem Gezgini \'e7al\'fd\'fet\'fdrmak gerekir. B\'fct\'fcn istemci uygulamalar\'fdn kapanmas\'fd sizin i\'e7in yeterli g\'f6r\'fcnebilir ama ger\'e7ek bu \'feekilde de\'f0ildir. Delphi IDE'si ger\'e7ekte sunucuya sergilenen metodlar\'fd ve s\'fdn\'fdflar\'fdn\'fd ara\'fet\'fdrmak i\'e7in otomatik olarak bir ba\'f0lant\'fd a\'e7ar. Sunucuyu durdurmadan \'f6nce b\'fct\'fcn SQLConnection nesnelerini kapatmay\'fd unutmamak gerekmektedir. \par
\cf1\lang1033\f0\fs24\par
\ul\b --- Sunucu Metodlar\u305? Ekleme ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab Ge\'e7mi\'fete oldu\'f0u gibi, \'feu anda da sunucu i\'e7erisine istemci taraftan \'e7a\'f0r\'fdlmas\'fd i\'e7in metodlar yazabiliriz. Bu COM teknolojisine dayal\'fd olup, bunlar i\'e7in \'f6ncelikle t\'fcr k\'fct\'fcphanesi (type library) ve aray\'fczleri (interface) eklemek, bunlar\'fd sunucu nesnelerinde tamamlamak, ve istemci tarafta COM yap\'fds\'fdn\'fd kullanarak bu metodlar\'fd \'e7a\'f0\'fdrmak gerekmektedir. DataSnap 2009'da uzaktan y\'f6netim metodlar\'fd \'e7a\'f0\'fdrma, sunucu metodlar\'fd \'e7a\'f0\'fdrma Delphi'nin \'c7al\'fd\'fema Zaman\'fd T\'fcr Tan\'fdmlamas\'fdna (RTTI = Run Time Type \'dddentification) aittir. \'d6nemli bir nokta olarak, bununla beraber ge\'e7i\'fe yapan parametreler Delphi'nin dil t\'fcr\'fc olmay\'fdp, dbExpress parametre t\'fcrlerine dayan\'fdr.\par
\tab Biz metodlar\'fd g\'f6steren \'e7oklu sunucu s\'fdn\'fdflar\'fdna sahip olabiliriz, ama daha \'f6nce olu\'feturdu\'f0umuz basit proje ile devam etmek i\'e7in sunucu uygulamas\'fdndaki sunucu mod\'fcl s\'fdn\'fdf\'fdna ekstra bir metod yazmak gerekir. Bununla ilgili kod a\'fea\'f0\'fddad\'fdr.\par
\par
\tab type \par
  \tab\tab TDSFirst3TierServerModule = class(TDSServerModule) \par
    \tab\tab\tab IBCONNECTION: TSQLConnection; \par
    \tab\tab\tab EMPLOYEE: TSQLDataSet; \par
    \tab\tab\tab DataSetProviderEmployee: TDataSetProvider; \par
  \tab\tab private \par
    \tab\tab\tab\{ Private declarations \} \par
  \tab\tab public \par
    \tab\tab\tab function GetHello: string; \par
  \tab\tab end; \par
 \par
\tab function TDSFirst3TierServerModule.GetHello: string; \par
\tab begin \par
  \tab\tab Result := 'Hello from TDSFirst3TierServerModule at '  \par
    \tab\tab + TimeToStr (Now); \par
\tab end; \par
\par
\tab Uzaktan y\'fcr\'fctmeyi yap\'fdlabilir hale getirmek i\'e7in metodlar\'fdn\'fd DSServerClass fabrikas\'fdna sergileyebilmek i\'e7in gerekli olan s\'fdn\'fdfa ba\'f0lanmam\'fdz gerekir. (Bu durumu biz zaten veritaban\'fd demo k\'fdsm\'fdnda ger\'e7ekle\'fetirdik.) \'ddkinci yapmam\'fdz gereken \'feey, $MethodInfo direktifi etkinle\'fetirilmi\'fe olarak derlenmi\'fe bir s\'fdn\'fdf\'fd kullanmakt\'fdr ama bu zaten ana s\'fdn\'fdf olan TDSServerModule s\'fdn\'fdf\'fdnda bir tan\'fdm olarak yer alm\'fd\'fet\'fdr. Bu da demek oluyor ki bizim daha \'f6nce yaz\'fdlan koda yapaca\'f0\'fdm\'fdz \'feey, sadece sunucu mod\'fcle public diye tabir edilen bir metod eklemektir. Bunun d\'fd\'fe\'fdnda gereken her \'feey yap\'fdlm\'fd\'fet\'fdr.\par
\tab\'ddstemci uygulamadan sunucu metodu nas\'fdl \'e7a\'f0\'fdrabiliriz? Bunun i\'e7in basit\'e7e 2 alternatif vard\'fdr. \'ddlki, yeni bir SqlServerMethod bile\'feeni kullanmak ve sunucu metodu sanki bir saklanan prosed\'fcr (stored procedure) gibi \'e7a\'f0\'fdrmakt\'fdr. \'ddkincisi ise, istemci uygulamada bir proxy s\'fdn\'fdf\'fd olu\'feturmak ve metodu \'e7a\'f0\'fdrmada bu s\'fdn\'fdf\'fd kullanmakt\'fdr.\par
\tab A\'fea\'f0\'fddaki istemci demosunda 2 metodu da uygulad\'fdm. \'ddlki i\'e7in istemcinin formuna bir SqlServerMethod bile\'feeni ekledim, ba\'f0lant\'fdya ba\'f0lad\'fdm, ServerMethodName \'f6zelli\'f0i i\'e7in Object \'ddnspector taraf\'fdnda bir de\'f0er ekledim (pek \'e7ok uygun de\'f0er aras\'fdnda standart IAppServer aray\'fcz metodlar\'fd da listelenmi\'fetir.), ve Params \'f6zelli\'f0inin de\'f0er alan\'fdn\'fd kontrol ettim. A\'fea\'f0\'fddaki kod bile\'feen ayarlar\'fdn\'fdn bir kopyas\'fdd\'fdr. (Yap\'fdlan \'f6rnek bir \'e7a\'f0r\'fdy\'fd parametreleri kontrol ederek uygularken ortaya \'e7\'fdkan sonucu da i\'e7erir.)\par
\par
\tab object SqlServerMethod1: TSqlServerMethod \par
  \tab\tab GetMetadata = False \par
  \tab\tab Params = < \par
    \tab\tab\tab item \par
      \tab\tab\tab\tab DataType = ftWideString \par
      \tab\tab\tab\tab Precision = 2000 \par
      \tab\tab\tab\tab Name = 'ReturnParameter' \par
      \tab\tab\tab\tab ParamType = ptResult \par
     \tab\tab\tab\tab Size = 2000 \par
      \tab\tab\tab\tab Value = 'Hello from TDSFirst3TierServerModule...' \par
    \tab\tab\tab end> \par
  \tab\tab SQLConnection = SQLConnection1 \par
  \tab\tab ServerMethodName = 'TDSFirst3TierServerModule.GetHello' \par
\tab end \par
\par
\tab Do\'f0al string t\'fcr\'fc, 2000 karakterlik bir string parametresi ile haritaland\'fdr\'fdlm\'fd\'fet\'fdr. SqlServerMethod bile\'feeninin konfig\'fcrasyonu bittikten sonra, program bu metou giri\'fe parametrelerini kullanarak (burada de\'f0il \'feu anda) ve \'e7\'fdk\'fd\'fe parametreleri (sonu\'e7 olarak) ile  bir stored procedure veya sorgu c\'fcmleci\'f0i (query) gibi \'e7a\'f0\'fdrabilir.\par
\par
\tab procedure TFormFirst3Tier2009Client.btnHelloClick( \par
  \tab Sender: TObject); \par
\tab begin \par
  \tab\tab SqlServerMethod1.ExecuteMethod; \par
  \tab\tab ShowMessage (SqlServerMethod1.Params[0].Value); \par
\tab end;  \par
\par
\tab\'c7a\'f0\'fdrma kodunu daha kolay bir \'feekilde yazabilmek i\'e7in daha \'f6nce de bahsetti\'f0im istemci uygulama i\'e7erisinde bir proxy s\'fdn\'fdf\'fd olu\'feturma daha yararl\'fd olur bizim a\'e7\'fdm\'fdzdan. Bunu ba\'fearabilmek i\'e7in Delphi IDE'sini sunucu s\'fdn\'fdf\'fdn aray\'fcz\'fcn\'fc parse edecek ve lokal bir proxy s\'fdn\'fdf\'fd olu\'feturacak bir \'feekilde kullanabiliriz. (SQLConnection bile\'feenine t\'fdklayarak DataSnap Olu\'fetur (Generate DataSnap) komutunu \'e7al\'fd\'fet\'fdrarak otomatik olarak halledebiliriz.) \'d6rne\'f0in bu kesiminde Delphi bize otomatik olarak bir unit ve bununla ilgili s\'fdn\'fdf\'fd olu\'feturacakt\'fdr. (A\'fea\'f0\'fddaki kodda yap\'fdc\'fd ve y\'fdk\'fdc\'fd kesimler ihmal edilmi\'fetir. (Constructor ve destructor) )\par
\par
\tab type \par
  \tab TDSFirst3TierServerModuleClient = class \par
  \tab private \par
    \tab\tab FDBXConnection: TDBXConnection; \par
\tab\tab FInstanceOwner: Boolean; \par
    \tab\tab FGetHelloCommand: TDBXCommand; \par
  \tab public \par
    \tab\tab constructor Create( \par
      \tab\tab ADBXConnection: TDBXConnection); overload; \par
    \tab\tab constructor Create( \par
      \tab\tab ADBXConnection: TDBXConnection;  \par
      \tab\tab AInstanceOwner: Boolean); overload; \par
    \tab\tab destructor Destroy; override; \par
    \tab\tab function GetHello: string; \par
  \tab end; \par
 \par
\tab function TDSFirst3TierServerModuleClient.GetHello: string; \par
\tab begin \par
  \tab\tab if FGetHelloCommand = nil then \par
  \tab\tab begin \par
    \tab\tab\tab FGetHelloCommand := FDBXConnection.CreateCommand; \par
    \tab\tab\tab FGetHelloCommand.CommandType := \par
      \tab\tab\tab TDBXCommandTypes.DSServerMethod; \par
    \tab\tab\tab FGetHelloCommand.Text := \par
      \tab\tab\tab 'TDSFirst3TierServerModule.GetHello'; \par
    \tab\tab\tab FGetHelloCommand.Prepare; \par
  \tab\tab end; \par
 \par
  \tab\tab FGetHelloCommand.ExecuteUpdate; \par
  \tab\tab Result := FGetHelloCommand.Parameters[0]. \par
    \tab\tab Value.GetWideString; \par
\tab end; \par
\par
\par
\tab Olu\'feturulmu\'fe kod kesimi, y\'fcksek seviye olan SqlServerMethod bile\'feenini kullanmaz ama TDBXCommand s\'fdn\'fdf\'fd gibi d\'fc\'fe\'fck seviye dbExpress uygulama nesnelerini direk olarak \'e7a\'f0\'fdrabilir.\par
\tab Bu proxy s\'fdn\'fdf\'fdn\'fd kullan\'fdlabilir hale getirmek i\'e7in, \'feu anda istemci program \'fczerinden sunucu taraftaki bu metodu daha dil-dostu bir \'feekilde \'e7a\'f0\'fdrabiliriz, yaln\'fdz proxy s\'fdn\'fdftan bir varl\'fd\'f0\'fd olu\'feturmam\'fdz gerekir (ya da bir kere olu\'feturup onu saklamak). A\'fea\'f0\'fddaki kod SqlServerMethod bile\'feeni ile ilgili olarak yaz\'fdlan kod ile ayn\'fd i\'felemi yapar.\par
\par
\tab procedure TFormFirst3Tier2009Client.btnHelloClick( \par
  \tab Sender: TObject); \par
\tab begin \par
  \tab\tab with TDSFirst3TierServerModuleClient.Create( \par
    \tab\tab SQLConnection1.DBXConnection) do \par
  \tab\tab try \par
    \tab\tab\tab ShowMessage (GetHello); \par
  \tab\tab finally \par
    \tab\tab\tab Free; \par
  \tab\tab end; \par
\tab end; \par
\par
\tab Bu kod par\'e7as\'fd daha \'f6ncekine g\'f6re biraz daha uzun olabilir, bunun sebebi de herhangi bir parametre istememesindendir, ki bu da dile ba\'f0l\'fd kodlamay\'fd daha aza indirgemeyi sa\'f0lar. Hala, kullanmaya haz\'fdr bir proxy nesnemiz oldu\'f0undan, \'feunu yazabiliriz.\par
\par
\tab ShowMessage (ServerProxyObject.GetHello); \par
\par
\par
\par
\cf1\lang1033\f0\fs24\par
\ul\b --- Veritabans\u305?z Bir DataSnap Sunucusunda Oturum ve Thread \lang1055\f2\'dd\lang1033\f0\'balemleri ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab E\'f0er DataSnap 2009 yap\'fds\'fdn\'fd kullanmak i\'e7in en s\'fdk kullan\'fdlan metod olan IAppServer aray\'fcz\'fcn\'fc direkt olarak kullan\'fdrsak, veritaban\'fd i\'e7eri\'f0i d\'fd\'fe\'fdnda uzaktan metod y\'fcr\'fctme i\'felemlerini \'e7ok katmanl\'fd bir \'feekilde ger\'e7ekle\'fetirmek de m\'fcmk\'fcn olabilir. Ayn\'fd teknolojiyi kullanarak IAppServer olmadan da veritaban\'fdna eri\'feim ve veritaban\'fd \'fczerinde i\'felemler yapmak da m\'fcmk\'fcn olabilir, e\'f0er yapmak istedi\'f0imiz \'feey sadece sunucudan veri okumak ise. E\'f0er istemci makinaya sunucudaki veriyi de\'f0i\'fetirerek sunucuya tekrar yazmas\'fdn\'fd istiyorsak, geleneksel metodlar\'fd kullanmak, ClientDataSet ve DataSetProvider bile\'feenleri taraf\'fdndan sa\'f0lanan kullanmaya haz\'fdr IAppServer'a g\'f6re son derece b\'fdkt\'fdr\'fdc\'fd olabilir.\par
\tab Her hal\'fckarda, ikinci \'f6rnekte ben bir \'e7ok s\'fdn\'fdf\'fd sergileyecek bir minimum bir sunucu olu\'feturmak istiyorum. \'ddlerleyen b\'f6l\'fcmlerde bir ka\'e7 ili\'fekili olay\'fd (sunucu bellek y\'f6netimi, sunucu ve istemci baz\'fdnda thread i\'felemleri gibi) \'e7\'f6zmek i\'e7in bu olu\'feturaca\'f0\'fdm \'f6rnek s\'fdn\'fdf\'fd kullanaca\'f0\'fdm.\par
\tab DSnapMethodServer projesinde yay\'fdnlamak istedi\'f0im ilk sunucu a\'fea\'f0\'fddakidir. (2 metodu bulunmakta)\par
\par
\tab\{$MethodInfo ON\} \par
\tab type \par
  \tab\tab TSimpleServerClass = class(TPersistent) \par
  \tab\tab public \par
    \tab\tab\tab function Echo (const Text: string): string; \par
    \tab\tab\tab function SlowPrime (MaxValue: Integer): Integer; \par
  \tab\tab end; \par
\tab\{$MethodInfo OFF\} \par
\par
\tab\par
\tab\'ddlk metodun codu basit\'e7e inputu yans\'fdt\'fdr, son k\'fdsm\'fdn\'fd tekrar eder, ikinci metod da klasik bir \'feekilde yava\'fe\'e7a hesaplama yapar. A\'fea\'f0\'fdda 2 metodun da kodu bulunmaktad\'fdr.\par
\par
\tab function TSimpleServerClass.Echo( \par
 \tab const Text: string): string; \par
\tab begin \par
  \tab\tab Result := Text + '...' + \par
    \tab\tab Copy (Text, 2, maxint) + '...' + \par
    \tab\tab Copy (Text, Length (Text) - 1, 2); \par
\tab end; \par
 \par
\tab function TSimpleServerClass.SlowPrime( \par
  \tab MaxValue: Integer): Integer; \par
\tab var \par
  \tab\tab I: Integer; \par
\tab begin \par
  \tab\tab // counts the prime numbers below the given value \par
  \tab\tab Result := 0; \par
  \tab\tab for I := 1 to MaxValue do \par
  \tab\tab begin \par
    \tab\tab\tab if IsPrime (I) then \par
      \tab\tab\tab\tab Inc (Result); \par
  \tab\tab end; \par
\tab end;  \par
\par
\tab Yukar\'fddaki kod kesiminde sunucunun loglamas\'fd ile ilgili kodlar\'fd yazmad\'fdm.\par
\tab Buradaki Sunucu uygulamas\'fd, ana form ve 2 adet sunucu tarafl\'fd s\'fdn\'fdf\'fd i\'e7eren tek bir unit'ten olu\'femaktad\'fdr. Form, geleneksel olan DataSnap sunucu bile\'feenlerini (1 adet DSServer ve 1 adet DSTCPServerTransport) ve 2 tane de sergilemek istedi\'f0imiz s\'fdn\'fdflar i\'e7in kulland\'fd\'f0\'fdm\'fdz DSServerClass bile\'feeni i\'e7erir. Sunucuyu derleyip ba\'felatt\'fdktan sonra Delphi'ye yeni istemci uygulaman\'fdn SQLConnection bile\'feenini kullanacak bir proxy s\'fdn\'fdf\'fd olu\'feturmas\'fdna izin veririm. A\'fea\'f0\'fddaki kod, istemci proxy s\'fdn\'fdf\'fdna aittir.\par
\par
\tab type \par
  \tab TSimpleServerClassClient = class \par
  \tab\tab private \par
    \tab\tab\tab FDBXConnection: TDBXConnection; \par
    \tab\tab\tab FInstanceOwner: Boolean; \par
    \tab\tab\tab FEchoCommand: TDBXCommand; \par
    \tab\tab\tab FSlowPrimeCommand: TDBXCommand; \par
  \tab\tab public \par
    \tab\tab\tab constructor Create( \par
      \tab\tab\tab ADBXConnection: TDBXConnection); overload; \par
    \tab\tab\tab constructor Create( \par
      \tab\tab\tab ADBXConnection: TDBXConnection;  \par
      \tab\tab\tab AInstanceOwner: Boolean); overload; \par
    \tab\tab\tab destructor Destroy; override; \par
    \tab\tab\tab function Echo(Text: string): string; \par
    \tab\tab\tab function SlowPrime(MaxValue: Integer): Integer; \par
  \tab\tab end; \par
\par
\tab\'ddstemci programda, butonun OnClick olay\'fd, sunucudaki Echo (Yans\'fdma) metodunu \'e7a\'f0\'fdr\'fdr, e\'f0er bir proxy s\'fdn\'fdf\'fd nesnesi olu\'feturulmam\'fd\'fesa olu\'feturulduktan sonra \'e7a\'f0r\'fdl\'fdr.\par
\par
\tab procedure TFormDsnapMethodsClient.btnEchoClick( \par
 \tab Sender: TObject); \par
\tab begin \par
  \tab\tab if not Assigned (SimpleServer) then \par
    \tab\tab\tab SimpleServer := TSimpleServerClassClient.Create ( \par
      \tab\tab\tab SQLConnection1.DBXConnection); \par
  \tab\tab Edit1.Text := SimpleServer.Echo(Edit1.Text); \par
\tab end; \par
\par
\tab\'d6rnekte, \'f6rnek metin olarak "Marco" verildi\'f0inde ve butona t\'fdkland\'fd\'f0\'fdnda "Marco" server taraf\'fdndan \'e7a\'f0r\'fdld\'fd\'f0\'fdnda "Marco..arco...co" \'feekline \'e7evrilir. Bu, IAppServer kullan\'fdlmadan, veritaban\'fd eri\'feimi bulunmadan b\'fct\'fcn\'fcyle bir sunucu olu\'feturmaya iyi bir \'f6rnektir. Bu metod Delphi'de method y\'f6netme i\'e7in kullan\'fdlan tek teknik de\'f0ildir, soket bazl\'fd uygulamalarda SOAP da kullan\'fdlabilir, ya da 3. parti ara\'e7lar da kullan\'fdlabilir. Ama bu y\'f6ntemin uzaktan veritaban\'fdna eri\'feim yetene\'f0i ekstra bir \'f6zellik olarak b\'fcy\'fck bir art\'fdd\'fdr bizim a\'e7\'fdm\'fdzdan.\par
\tab Bu \'f6rne\'f0e odaklanmam\'fdn sebeplerinden biri de DataSnap 2009'un baz\'fd ili\'fekili \'f6zelliklerine de a\'e7\'fdkl\'fdk getiriyor olmas\'fdd\'fdr. Bunlardan biri, sunucu tarafl\'fd nesnelerin istemci taraf\'fdndaki proxy'lere veya sunucu metod y\'fcr\'fctme i\'felemi ile ili\'fekili olmas\'fdd\'fdr. Bu, kendi durumunun izini tutan br s\'fdn\'fdf nesnesi ile daha iyi bir \'feekilde g\'f6sterilebilir. T\'fdpk\'fd demo proje i\'e7erisindeki 2. sunucu s\'fdn\'fdf\'fd gibi.\par
\par
\tab\{$MethodInfo ON\} \par
\tab type \par
  \tab\tab TStorageServerClass = class(TPersistent) \par
  \tab\tab private \par
    \tab\tab\tab FValue: Integer; \par
  \tab\tab public \par
    \tab\tab\tab procedure SetValue(const Value: Integer); \par
    \tab\tab\tab function GetValue: Integer; \par
    \tab\tab\tab function ToString: string; override; \par
 \tab\tab published \par
    \tab\tab\tab property Value: Integer read GetValue write SetValue; \par
  \tab\tab end; \par
\tab\{$MethodInfo OFF\} \par
\par
\tab Getter ve Setter metodlar lokal alan\'fd basit\'e7e okur ve yazarlar, ToString fonksiyonu ise hem de\'f0eri hem de nesne belirleyicisini tan\'fdmland\'fd\'f0\'fd hash kodu ile d\'f6nd\'fcr\'fcr.\par
\par
\tab function TStorageServerClass.ToString: string; \par
\tab begin \par
  \tab\tab Result := 'Value: ' + IntToStr (Value) + \par
    \tab\tab ' - Object: ' + IntToHex (GetHashCode, 4); \par
\tab end;\par
\par
\tab Bu metodu bir sunucu nesnesinin ya\'feam d\'f6ng\'fcs\'fcn\'fcn nas\'fdl \'e7al\'fd\'fet\'fd\'f0\'fdn\'fd g\'f6stermek i\'e7in yazd\'fdm. S\'fdn\'fdfta \'f6zellik tan\'fdm\'fd, bu nesnenin istemci tarafa sergilenmeyece\'f0ini, sadece sunucuya has bir \'feey oldu\'f0unu belirtiyor. \'ddli\'fekili proxy'nin aray\'fcz\'fc, \'f6zel alanlar\'fd, yap\'fdc\'fd ve y\'fdk\'fdc\'fd metodlar\'fd \'e7\'fdkard\'fdktan sonra \'feu hali al\'fdyor.\par
\par
\tab type \par
  \tab TStorageServerClassClient = class \par
  \tab\tab public \par
   \tab\tab\tab procedure SetValue(Value: Integer); \par
    \tab\tab\tab function GetValue: Integer; \par
    \tab\tab\tab function ToString: string;\par
\par
\tab\'deunu vurgulamak gerekir ki kulland\'fd\'f0\'fdm\'fdz fonksiyonu "Override" olarak i\'fearetlemezsek, s\'fdn\'fdf bize a\'fea\'f0\'fddaki uyar\'fdy\'fd getirecektir.\par
\par
\tab Method 'ToString' hides virtual method of base type 'TObject' \par
\par
\tab Bu \'f6rne\'f0in amac\'fd, birden fazla istemci uygulaman\'fdn ayn\'fd sunucuyu kullanmak istedi\'f0i zaman neler olaca\'f0\'fdn\'fd g\'f6stermek idi. DataSnap 2009 Sunucusunun davran\'fd\'fe\'fd, kullan\'fdlan DSServerClass bile\'feeni i\'e7erisindeki LifeCycle (Ya\'feam D\'f6ng\'fcs\'fc) string de\'f0erine ba\'f0l\'fd olarak de\'f0i\'feir.\par
\cf1\lang1033\f0\fs24\par
\ul\b --- Sunucu Nesneleri Ya\'baam D\'f6ng\'fcs\'fc ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab DataSnap 2009 sunucu nesnesinin ya\'feam d\'f6ng\'fcs\'fc, ili\'fekili oldu\'f0u DSServerClass bile\'feeninin ayarlar\'fdna ba\'f0l\'fdd\'fdr. Bu bile\'feenin LifeCycle ad\'fdndaki \'f6zelli\'f0i, 3 adet string t\'fcr\'fcnde de\'f0eri bar\'fdnd\'fdr\'fdr (DSServerClass bile\'feeni taraf\'fdndan DSServer nesnesi a\'e7\'fdksa, \'e7al\'fd\'fema zaman\'fdndaki (runtime) de\'f0i\'feiklikleri olmam\'fd\'fe sayarak okur)\par
\tab Session (Oturum) : Sunucu, her istemci soket ba\'f0lant\'fds\'fd i\'e7in yeni bir nesne olu\'feturur ki bu nesne her istemci i\'e7in bir sunucu nesnedir. Sunucu nesneleri ba\'f0lant\'fd kapand\'fd\'f0\'fd zaman serbest b\'fdrak\'fdl\'fdr. \'c7oklu kullan\'fdc\'fdlar, e\'f0er sunucu nesnesi bir data module ise birbirinden ba\'f0\'fdms\'fdz durumlara ve ayr\'fd veritaban\'fd eri\'feimlerine, belki kendi veritaban\'fd eri\'feim bile\'feenleri ile sahip olurlar. Bu varsay\'fdlan ayarlamad\'fdr.\par
\tab\'ddnvocation (Y\'fcr\'fctme) : Sunucu method her y\'fcr\'fct\'fcld\'fc\'f0\'fcnde yeni bir sunucu nesnesinin olu\'feturulup sonras\'fdnda serbest b\'fdrak\'fdlaca\'f0\'fdn\'fd belirtir. Bu klasik durumsuz bir davran\'fd\'fet\'fdr, sunucuyu \'f6l\'e7\'fclebilir bir halde tutar ve ayn\'fd zamanda ayn\'fd verinin gidip gelmesini tekrar ve tekrar konu eder.\par
\tab Server (Sunucu) : Payla\'fe\'fdlan bir sunucu nesnesini, bir singleton'u belirtir. Her kullan\'fdc\'fd, ayn\'fd sunucu nesnesini, ayn\'fd veriyi kullanacakt\'fdr ve bundan dolay\'fd senkronizasyon problemleri olacakt\'fdr. (Farkl\'fd istemci y\'fcr\'fctmeleri, farkl\'fd sunucu threadleri ile tetiklenerek \'e7\'f6z\'fcmlenebilir.) Payla\'fe\'fdlan sunucu nesnesine eri\'feim senkronizasyon teknikleri ile konuma alt\'fdna al\'fdnabilir. (Mesela yeni bir TMonitor kayd\'fd tutularak)\par
\par
\tab Bu varsay\'fdlan ayarlar\'fd kullanmak d\'fd\'fe\'fdnda, sunucu taraf\'fdndaki nesnelerin olu\'feturulmas\'fd ve yok edilmesi DSServerClass bile\'feeninin OnCreateInstance ve OnDestroyInstance olaylar\'fd tetiklenerek de yap\'fdlabilir. Bu sunucu nesneleri havuzlamas\'fdnda da kullan\'fdlabilir.\par
\cf1\lang1033\f0\fs24\par
\ul\b --- Sunucuyu Ba\'balatan ve \'c7oklu Oturum A\'e7an \lang1055\f2\'dd\lang1033\f0 stemci ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab Uygulamal\'fd bir \'f6rnek olarak, DSnapMethods projesi tek bir istemci uygulamadan birden \'e7ok istemci ba\'f0lant\'fdn\'fdn olu\'feturulmas\'fdna m\'fcsade etmketedir. (Birden \'e7ok uygulama kullanmak da ayn\'fd sonucu sa\'f0lar). Form \'fczerinde SQLConnection bile\'feenii bulunduran birden \'e7ok varl\'fdk olu\'feturulabilir, bunu en ba\'feta olu\'feturulan bir istemci proxy'nin lokal nesnesi i\'e7erisinde saklayabilirsiniz. \'ddstemci sadece \'e7oklu istemci ba\'f0lant\'fd olu\'feturmakla kalmaz, ayn\'fd zamanda sunucu program\'fd belirlenen bir ya\'feam d\'f6ng\'fcs\'fc ayarlamas\'fd ile ba\'felatmak da m\'fcmk\'fcnd\'fcr. Bunu ba\'fearmak, istemci ve sunucu uygulamalar ayn\'fd bilgisayarda oldu\'f0undan olduk\'e7a kolayd\'fdr.\par
\tab Bunu ba\'fearmak i\'e7in sunucunun ana formunu belirten unit i\'e7erisine DSServerClass bile\'feeninin LifeCycle \'f6zelli\'f0ini belirlemesi i\'e7in global bir de\'f0i\'feken ekleriz.\par
\par
\tab var \par
  \tab ParamLifeCycle: string; \par
 \par
\tab procedure TFormDsnapMethodsServer.DSServerClass2GetClass( \par
  \tab DSServerClass: TDSServerClass;  \par
  \tab var PersistentClass: TPersistentClass); \par
\tab begin \par
  \tab\tab DSServerClass2.LifeCycle := ParamLifeCycle; \par
  \tab\tab Log ('LifeCycle: ' + DSServerClass2.LifeCycle); \par
  \tab\tab PersistentClass := TStorageServerClass; \par
\tab end; \par
\par
\tab ParamLifeCycle adl\'fd de\'f0i\'fekenin ilk de\'f0erini proje dosyas\'fd kaynak kodunun ba\'fe\'fdnda sunucu uygulamas\'fdn\'fdn komut sat\'fdr\'fdnda ald\'fd\'f0\'fd parametrelerle a\'fea\'f0\'fddaki gibi belirleyebiliriz.\par
\par
\tab begin \par
 \tab\tab if ParamCount > 0 then \par
    \tab\tab\tab ParamLifeCycle := ParamStr(1); \par
  \tab\tab Application.Initialize; \par
\par
\tab Sunucuda bulunan bu kodla, istemci uygulaman\'fdn ana formunda (burada ba\'f0lant\'fd yok, ba\'f0lant\'fd ikincil formlarla ayarlan\'fdyor) bir RadioGroup olu\'feturularak a\'fea\'f0\'fddaki kod yaz\'fdl\'fdr.\par
\par
\tab object rgLifeCycle: TRadioGroup \par
  \tab\tab ItemIndex = 0 \par
  \tab\tab Items.Strings = ( \par
    \tab\tab 'Session' \par
    \tab\tab 'Invocation' \par
    \tab\tab 'Server') \par
\tab end \par
\par
\tab Butona t\'fdkland\'fd\'f0\'fd zaman, istemci program g\'fcncel de\'f0eri al\'fdr ve bu de\'f0erleri sunucuya parametre olarak g\'f6nderir (Sunucuyu iki kez \'e7al\'fd\'fet\'fdramayaca\'f0\'fdm\'fdz\'fd, ayn\'fd makinadan ayn\'fd anda 2 uygulamalayla ayn\'fd portu kullanarak ayn\'fd soketi dinleyemeyece\'f0imizi unutmamak gerekir.). \'ddlgili kod a\'fea\'f0\'fddad\'fdr.\par
\par
\tab procedure TFormDsmcMain.btnStartServerClick( \par
 \tab Sender: TObject); \par
\tab var \par
  \tab\tab aStr: AnsiString; \par
\tab begin \par
  \tab\tab Log (rgLifeCycle.Items[rgLifeCycle.ItemIndex]); \par
  \tab\tab aStr := 'DsnapMethodsServer.exe ' + \par
    \tab\tab rgLifeCycle.Items[rgLifeCycle.ItemIndex]; \par
  \tab\tab WinExec (PAnsiChar (aStr), CmdShow); \par
\tab end; \par
\par
\tab\'deu anda istemci uygulaman\'fdn ana formu ikincil formlar\'fd olu\'feturacak, OnClose olay\'fdn\'fdn tetiklenmesine ba\'f0l\'fd olarak sunucuya yap\'fdlacak \'f6zelle\'femi\'fe ba\'f0lant\'fdlar\'fd kapatacak ve bu \'feekilde olu\'feturulan formlar\'fd yok edecek bir butona sahip olmu\'fetur. O an kullan\'fdlan istemci formlar\'fdn durumlar\'fdn\'fdn loglanmas\'fd i\'e7in ayr\'fd bir buton kullan\'fdlmal\'fdd\'fdr. Bununla ilgili kod a\'fea\'f0\'fddad\'fdr.\par
\par
\tab procedure TFormDsmcMain.btnUpdateStatusClick( \par
  \tab Sender: TObject); \par
\tab var \par
  \tab\tab I: Integer; \par
\tab begin \par
  \tab\tab for I := 0 to Screen.FormCount - 1 do \par
    \tab\tab\tab if Screen.Forms[I].ClassType = TFormDsmcClient then \par
      \tab\tab\tab\tab Log (IntToStr (I) + ': ' + \par
        \tab\tab\tab\tab Screen.Forms[I].ToString); \par
\tab end; \par
\par
\tab\'ddkincil formlar\'fdn birinden ToString fonksiyonu \'e7a\'f0r\'fdld\'fd\'f0\'fd zaman, bu public t\'fcrdeki ToString metodunu \'e7a\'f0\'fdrarak ba\'f0land\'fd\'f0\'fd sunucu nesnesinin durumunu d\'f6nd\'fcr\'fcr.\par
\par
\tab function TFormDsmcClient.ToString: string; \par
\tab begin \par
  \tab\tab InitStorageServer; \par
  \tab\tab Result := StorageServer.ToString; \par
\tab end; \par
\par
\tab\'ddlk uygulama \'f6rne\'f0inde, varsay\'fdlan Oturum ya\'feam d\'f6ng\'fcs\'fc ile bir sunucu olu\'feturdum, 2 istemci form a\'e7t\'fdm, de\'f0erlerini 3 ve 4 olarak atad\'fdm, ve b\'fct\'fcn durumunu sordu\'f0umda \'fe\'f6yle bir sonu\'e7 \'e7\'fdkt\'fd\par
\par
\tab Session \par
\tab 1: Value: 3 - Object: 1C38400 \par
\tab 2: Value: 4 - Object: 1C384E0\par
\par
\tab\'ddkinci uygulamada \'ddnvocation ya\'feam d\'f6ng\'fcs\'fc ile yapt\'fdm ve b\'fct\'fcn durumu iki kere istedi\'f0im zaman \'fe\'f6yle bir sonu\'e7 \'e7\'fdkt\'fd\par
\par
\tab Invocation \par
\tab 1: Value: 0 - Object: 1D185B0 \par
\tab 2: Value: 0 - Object: 1D18490 \par
\tab 1: Value: 0 - Object: 1D185C0 \par
\tab 2: Value: 0 - Object: 1D185D0  \par
\par
\tab Burada her uygulama i\'e7in yeni bir nesne elde etti\'f0imizi ve bu nesnenin durumunun her zaman 0 oldu\'f0unu unutmamak gerekir. (Her y\'fcr\'fctmeden sonra nesne yok oldu\'f0unda b\'fct\'fcn ayarlar da otomatik olarak yok olur). Bu olay, sadece durumsuz i\'felemlerde mant\'fdk kazan\'fdr.\par
\tab En sonunda ilk uygulamadaki gibi Server ya\'feam d\'f6ng\'fcs\'fc ayarlar\'fdyla 3 ve 4 de\'f0erlerini atad\'fdm, ve bu sefer her istemci formu, ayn\'fd sunucu nesnesini kulland\'fd ve son de\'f0er atamas\'fd ile kullan\'fdlm\'fd\'fe oldu. \'de\'f6yle bir sonu\'e7 \'e7\'fdkt\'fd ortaya\par
\par
\tab Server \par
\tab 1: Value: 4 - Object: 1E08490 \par
\tab 2: Value: 4 - Object: 1E08490 \par
\par
\tab Di\'f0er bir deyi\'fele, al\'fd\'fet\'fdrma g\'f6sterdi ki teori do\'f0ruymu\'fe. Demoda ya\'feam d\'f6ng\'fcs\'fc konfig\'fcrasyonunu incelerken g\'f6rd\'fck ki, istemci lokal sunucuyu ihtiya\'e7 duyuldu\'f0unda ba\'felatabiliyor ve sunucuya e\'fe zamanl\'fd olarak \'e7oklu ba\'f0lant\'fd kurabiliyor.\par
\cf1\lang1033\f0\fs24\par
\ul\b --- Eski DataSnap Yap\u305?s\u305?n\u305? Yeni Sisteme Ge\'e7irmek ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab DataSnap 2009 ile baz\'fd alternatiflere y\'f6neldikten sonra, m\'fcsaade edin biraz eskiye gideyim, en \'e7ok kullan\'fdlan klasik senaryoya, \'e7ok katmanl\'fd veritaban\'fd uygulamas\'fdna. Hali haz\'fdrda yeni bir DataSnap veritaban\'fd uygulamas\'fdn\'fdn nas\'fdl olu\'feturulaca\'f0\'fdna ili\'fekin ad\'fdmlar\'fd g\'f6rd\'fck. \'deimdi g\'f6rece\'f0imiz \'feey ise eski bir DataSnap (ya da MIDAS) uygulamas\'fdn\'fd bu mimariye g\'f6re \'feekillendirmek.\par
\par
\tab Uygulamal\'fd bir \'f6rnek olarak, Mastering Delphi 2005'te bahsetti\'f0im ThinPlus uygulamas\'fdn\'fd yeni yap\'fdya ge\'e7irece\'f0im. \'c7\'fcnk\'fc hem DataSnap'in bir ka\'e7 yetene\'f0ini g\'f6stermi\'fe olaca\'f0\'fdm, hem de \'fczerinde tamamen \'e7al\'fd\'feabilece\'f0im bir proje. Bu uygulama ile ayn\'fd zamanda COM sunucusuna soket kullanarak y\'fcr\'fctme g\'f6nderen bir istemciyi nas\'fdl saf soket tabanl\'fd mimariye \'e7evirece\'f0ime de dikkat etmek gerekecek. Yeni \'f6rnek, sunucu ve istemci dosyalar\'fdyla birlikte ThinPlus2009 klas\'f6r\'fc i\'e7erisinde olacak\par
\tab Unutmamak gerekir ki, eski modeli yeni DataSnap modeline \'e7evirmek ilgin\'e7 bir \'f6neridir ama zorunlu de\'f0ildir. Eski mimarinin istemci ve sunucular\'fd da Delphi 2009 i\'e7erisinde derlenip \'e7al\'fd\'fet\'fdr\'fdlabilir.(Program Mastering Delphi 2005'te oldu\'f0u gibi Mastering Delphi 7 i\'e7inde de bulunmaktad\'fdr.Ben burada baz\'fd \'f6zeliiklerini kullanaca\'f0\'fdm, bu kitaplar DataSnap ve MIDAS hakk\'fdnda projenin sahip oldu\'f0u pek \'e7ok \'f6zellikten bahsetmektedir.)\par
\par
\tab\par
\par
\tab\par
\cf1\lang1033\f0\fs24\par
\ul\b --- Sunucuyu Yeni Sisteme Ge\'e7irmek ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab Sunucu projeyi yeni sisteme \'e7evirmek i\'e7in \'feu ad\'fdmlar\'fd takip ettim.\par
\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-200\li920 AppsRDM ad\'fd verilen uzaktan y\'f6netim data module unit dosyas\'fd i\'e7erisindeki initialization b\'f6l\'fcm\'fcn\'fc kald\'fdrd\'fdm. Kald\'fdr\'fdlan kod, TComponentFactory s\'fdn\'fdf\'fdn\'fdn yap\'fdc\'fds\'fdn\'fd (constructor) \'e7a\'f0\'fdrmak i\'e7indi.\par
{\pntext\f4\'B7\tab}Ayn\'fd data module unit dosyas\'fd i\'e7erisindeki TAppServerPlus s\'fdn\'fdf\'fdn\'fdn UpdateRegistry s\'fdn\'fdf metodunu da kald\'fdrd\'fdm.\par
{\pntext\f4\'B7\tab}Bu noktada uzaktan y\'f6netim data module i\'e7erisinde COM ve ActiveX ile ili\'fekili uses kesimlerini de kald\'fdrd\'fdm (ComServ, ComObj, VCLCom ve StdVcl)\par
{\pntext\f4\'B7\tab}Sonra IAppServerPlus aray\'fcz\'fcn\'fcn (interface) referans\'fdn\'fd, ki proje taraf\'fdndan sunucu metodlar\'fdn\'fd desteklemek i\'e7in kullan\'fdl\'fdyor, kald\'fdrd\'fdm. (Bu aray\'fcz, proje t\'fcr k\'fct\'fcphanesinde tan\'fdml\'fdd\'fdr.)\par
{\pntext\f4\'B7\tab}T\'fcr k\'fct\'fcphanesini (type library) ve RTDL dosyalar\'fdn\'fd (projeyi Delphi 2009 i\'e7inde a\'e7\'fdnca otomatik olu\'feuyor) hem projeden hem de disk \'fczerinden sildim. Ayr\'fdca t\'fcr k\'fct\'fcphanesi unit'ini kullanan kodlardaki uses k\'fdsm\'fdndan da sildim t\'fcr k\'fct\'fcphanesini\par
{\pntext\f4\'B7\tab}Uzaktan y\'f6netim data mod\'fcl s\'fdn\'fdf\'fdnda tek sunucu metodu olan Login metodunu protected b\'f6l\'fcm\'fcnden alarak, public tan\'fdmlamalara \b safecall \b0 modifikasyonnunu kald\'fdrarak ta\'fe\'fdd\'fdm. Zaten TRemoteDataModule s\'fdn\'fdf\'fd $MethodInfo a\'e7\'fdk bir halde derlendi\'f0i i\'e7in bu tan\'fdm\'fd projenin unit dosyas\'fdnda bulundurmaya gerek yok.\par
{\pntext\f4\'B7\tab}En sonunda program\'fdn ana formuna geleneksel bile\'feen \'fc\'e7l\'fcs\'fcn\'fc ekledim (sunucu, sunucu s\'fdn\'fdf\'fd ve sunucu ta\'fe\'fdma), bunlar\'fd ba\'f0lad\'fdm ve sunucu s\'fdn\'fdf\'fd bile\'feeninin OnGetClass olay\'fd tetiklemesinde TAppServerPlus d\'f6nd\'fcrd\'fcm.\par
\pard\li720\par
\pard\tab Sadece bunlar\'fd yaparak eski modellemeden Delphi 2009'daki yeni DataSnap modeline g\'fcncelledim. \'c7ok gibi g\'f6r\'fcnse de asl\'fdnda \'e7ok \'e7abuk yap\'fdlmaktad\'fdr. \'deimdi de istemci uygulamaya bakaca\'f0\'fdz ve orada da birtak\'fdm i\'felemleri ger\'e7ekle\'fetirece\'f0iz.\par
\cf1\lang1033\f0\fs24\par
\ul\b --- \lang1055\f2\'dd\lang1033\f0 stemciyi G\'fcncellemek ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab\'ddstemci b\'f6l\'fcm\'fc yeni sistme ge\'e7irmek, Delphi 2009'da sunucudan daha kolayd\'fdr. Ana ad\'fdm ba\'f0lant\'fd bile\'feenlerini kald\'fdrmak ve bunlar\'fd SQLConnection ve DSProviderConnection ile yer de\'f0i\'fetirmek, sonras\'fdnda da yeni uzaktan y\'f6netim bile\'feenini ClientDataSet bile\'feenine ba\'f0lamakt\'fdr. (Bu uygulama i\'e7erisinde 3 tane var kullan\'fdc\'fdlar\'fdn ba\'f0lant\'fd \'e7e\'feitlili\'f0ine ba\'f0l\'fd olarak)\par
\tab De\'f0i\'fetirmek durumunda kalaca\'f0\'fdm tek kod par\'e7as\'fd Login sunucu metodunun \'e7a\'f0r\'fdld\'fd\'f0\'fd koddur. Bu, ba\'f0lant\'fd bile\'feenindeki OnAfterConnection'da olup, bunu SQLConnection bile\'feeninin ilgili olay\'fdna ta\'fe\'fdyaca\'f0\'fdm, A\'fea\'f0\'fddaki kod bu i\'fee yaramaktad\'fdr.\par
\par
\tab procedure TClientForm.SQLConnection1AfterConnect( \par
  \tab Sender: TObject); \par
\tab begin \par
  \tab\tab // was: ConnectionBroker1.AppServer. \par
  \tab\tab //        Login (Edit2.Text, Edit3.Text); \par
  \tab\tab SqlServerMethod1.ParamByName('Name').AsString := \par
    \tab\tab Edit2.Text; \par
  \tab\tab SqlServerMethod1.ParamByName('Password').AsString := \par
    \tab\tab Edit3.Text; \par
  \tab\tab SqlServerMethod1.ExecuteMethod; \par
\tab end; \par
\par
\tab Bu \'e7a\'f0r\'fdn\'fdn yapt\'fd\'f0\'fd i\'fe, istemcinin ba\'f0lant\'fd bilgilerini sunucuya g\'f6ndermektir. Sunucu bilgiyi do\'f0rular ve ba\'fear\'fdl\'fd ise sa\'f0lay\'fdc\'fdya (provider) verisini g\'f6sterir. \'deifre kontrol\'fc \'f6nemsiz, ama yakla\'fe\'fdm ilgin\'e7tir. Bu da sunucudaki Login metodudur.\par
\par
\tab procedure TAppServerPlus.Login( \par
  \tab const Name, Password: WideString); \par
\tab begin \par
  \tab\tab if Password <> Name then \par
    \tab\tab\tab raise Exception.Create ( \par
     \tab\tab  \tab 'Wrong name/password combination received'); \par
  \tab\tab ProviderDepartments.Exported := True; \par
  \tab\tab ServerForm.Add ('Login:' + Name + '/' + Password); \par
\tab end; \par
\par
\tab Burada sunucu taraf\'fdnda olu\'feturulan istisnai durumun (exception) sunucu taraf\'fdnda g\'f6r\'fcnt\'fclendi\'f0ini Fig\'fcr 3'te g\'f6rebilirsiniz.\par
\par
\tab\par
\cf1\lang1033\f0\fs24\par
\ul\b --- ThinPlus2009'un Geli\'bami\'ba \'d6zellikleri ---\ulnone\b0\par
\par
\cf0\lang1055\f1\fs20\tab Daha \'f6nce bahsetti\'f0im ad\'fdmlar\'fd ger\'e7ekle\'fetirerek, ThinPlus istemci ve sunucu uygulamalar\'fdn\'fd DataSnap 2009 yap\'fds\'fdna g\'fcncelledim. \'c7e\'feitli \'f6zelle\'fetirmelerle daha kompleks bir yap\'fdya d\'f6n\'fc\'fet\'fcrd\'fcm. Bunlara \'f6rnek olarak, veri paketlerinin elle gidip gelmesi, master/detay yap\'fds\'fd kullan\'fdm\'fd, parametrik sorgular\'fd \'e7al\'fd\'fet\'fdrma, veri paketlerinin yan\'fdnda ekstra veri transferi, \'f6zel uzaktan ba\'f0lant\'fd ile login i\'felemleri benim g\'f6zlemlediklerimdir.\par
\tab Bu \'f6zelliklere k\'fdsaca g\'f6z att\'fd\'f0\'fdm\'fdzda daha \'f6nce DataSnap kullanmam\'fd\'fe insanlara, DataSnap'in g\'fcc\'fcn\'fc g\'f6stermek a\'e7\'fds\'fdndan son derece yararl\'fd olabilir. Daha \'f6nce yazm\'fd\'fe oldu\'f0umuz kodlar\'fd ne kadar kolay bir \'feekilde yeni mimariye \'e7evirebilmemiz gibi. Sunucu uygulama sa\'f0lay\'fdc\'fdya ba\'f0l\'fd olan master data set, bunu refere edecek data source ve data source'a refere edecek detay data source gibi ayarlamalar\'fd bar\'fdnd\'fdran bir master/detay yap\'fdy\'fd kullan\'fdyor.\par
\par
\tab object ProviderDepartments: TDataSetProvider \par
  \tab\tab DataSet = SQLDepartments \par
\tab end \par
\tab object SQLDepartments: TSQLDataSet \par
  \tab\tab CommandText = 'select * from DEPARTMENT' \par
  \tab\tab SQLConnection = SQLConnection1 \par
\tab end \par
\tab object DataSourceDept: TDataSource \par
  \tab\tab DataSet = SQLDepartments \par
\tab end \par
\tab object SQLEmployees: TSQLDataSet \par
  \tab\tab CommandText =  \par
    \tab\tab 'select * from EMPLOYEE where dept_no = :dept_no' \par
  \tab\tab DataSource = DataSourceDept \par
  \tab\tab Params = < \par
    \tab\tab\tab item \par
      \tab\tab\tab Name = 'dept_no' \par
      \tab\tab\tab ParamType = ptInput \par
    \tab\tab end> \par
  \tab\tab SQLConnection = SQLConnection1 \par
\tab end \par
\par
\tab\'ddstemci taraf\'fdnda program sa\'f0lay\'fdc\'fd ile ba\'f0lanan ilk ClientDataSet 'i ve burada ilkindeki \'f6zel bir data set alan\'fdna refere eden ikinci bir ClientDataSet kullan\'fdyor.\par
\par
\tab object cds: TClientDataSet \par
  \tab\tab FetchOnDemand = False \par
  \tab\tab PacketRecords = 5 \par
  \tab\tab ProviderName = 'ProviderDepartments' \par
  \tab\tab RemoteServer = DSProviderConnection1 \par
  \tab\tab object cdsDEPT_NO: TStringField... \par
  \tab\tab object cdsDEPARTMENT: TStringField... \par
  \tab\tab\tab ... \par
  \tab\tab object cdsSQLEmployees: TDataSetField \par
    \tab\tab\tab FieldName = 'SQLEmployees' \par
  \tab\tab end \par
\tab end \par
\tab object cdsDet: TClientDataSet\par
\tab\tab DataSetField = cdsSQLEmployees \par
\tab end \par
\par
\tab 2 ClientDataSet bile\'feeni i\'e7erisindeki veri, 2 ayr\'fd DBGrid i\'e7erisinde g\'f6sterilmektedir. Program\'fdn her veri paketinde sadece 5 kayd\'fd nas\'fdl al\'fdp verdi\'f0ini (PacketRecords \'f6zelli\'f0inde belirtildi), ilk paketten sonra al\'fdp verme i\'felemini kesti\'f0ini (FetchOnDemand \'f6zelli\'f0i False olarak tan\'fdmland\'fd), ve gridin tam dolmad\'fd\'f0\'fdn\'fd dikkatle incelemek gerekir. Bununla ilgili ekran g\'f6r\'fcnt\'fcs\'fcn\'fc Fig\'fcr 4'te g\'f6rebilirsiniz.\par
\tab Takip eden veri paketleri, form \'fczerinde ilgili buton t\'fdklanarak manuel olarak al\'fdn\'fdp verilebilir.\par
\par
\tab procedure TClientForm.btnFetchClick(Sender: TObject); \par
\tab begin \par
  \tab\tab btnFetch.Caption := IntToStr (cds.GetNextPacket); \par
\tab end; \par
\par
\tab Butonun Caption \'f6zelli\'f0inde program her paketle ka\'e7 kayd\'fdn al\'fdn\'fdp veridi\'f0ini g\'f6sterir. Bu yeteri kadar kay\'fdt varsa 5'tir, yoksa oldu\'f0u kadard\'fdr, b\'fct\'fcn kay\'fdtlar al\'fdnd\'fd\'f0\'fdnda da 0'd\'fdr. Her al\'fdp verme i\'feleminde grid daha fazla veri g\'f6sterir ve buna ba\'f0l\'fd olarak ScrollBar'\'fd da otomatik olarak d\'fczenlenir. Bu vakte kadar ka\'e7 kay\'fdt al\'fdnd\'fd\'f0\'fdn\'fd ayr\'fdca btnRecCount butonundan da \'f6\'f0renme imkan\'fdm\'fdz vard\'fdr.\par
\tab\par
\tab\'ddstemci program Query ad\'fdndaki buton t\'fdklanarak g\'f6sterilen ve farkl\'fd bir dataset'e sahip olan 2. bir forma sahiptir. Bu ClientDataSet bile\'feeni serverda tan\'fdmlanan parametrik bir sorgu ile ba\'f0lan\'fdr, \'fe\'f6yle ki;\par
\par
\tab object SQLWithParams: TSQLDataSet \par
  \tab\tab CommandText =  \par
    \tab\tab 'select * from employee where job_code = :job_code' \par
  \tab\tab Params = < \par
    \tab\tab item \par
      \tab\tab\tab DataType = ftString \par
      \tab\tab\tab Name = 'job_code' \par
      \tab\tab\tab ParamType = ptInput \par
      \tab\tab\tab Value = 'Eng' \par
    \tab\tab end> \par
  \tab\tab SQLConnection = SQLConnection1 \par
\tab end \par
\par
\tab\'ddstemci programda bir adet listbox vard\'fdr, bu listbox sunucuya parametre olarak g\'f6nderilecek ve tasar\'fdm zaman\'fdnda doldurulacak Departman \'ddsimleri ile doludur. \'deunu unutmamak gerekir ki, en ba\'feta parametrelerin tan\'fdmlamalar\'fdn\'fd g\'fcncelleyecek bir kod yazmak gerekir, bu i\'felem ClientDataSet bile\'feeni i\'e7in ilgili bile\'feen edit\'f6r\'fc komutu kullanarak tasar\'fdm zaman\'fdnda yap\'fdl\'fdr. \'ddstemcinin uzaktan parametrik sorgu \'e7al\'fd\'fet\'fdrmas\'fd i\'e7in gerekl olan \'e7a\'f0r\'fd \'feu \'feekildedir.\par
\par
\tab procedure TFormQuery.btnParamClick(Sender: TObject); \par
\tab begin \par
  \tab\tab cdsQuery.Close; \par
  \tab\tab cdsQuery.Params[0].AsString := ComboBox1.Text; \par
  \tab\tab cdsQuery.Open; \par
  \tab ... \par
\par
\tab Sunucu taraf\'fdnda, sorgu OnGetDataSetProperties olay\'fdnda \'e7al\'fd\'fet\'fdr\'fdld\'fd\'f0\'fd zaman sa\'f0lay\'fdc\'fd geri d\'f6nen paket i\'e7erisine ekstra veri ekler.\par
\par
\tab procedure TAppServerPlus. \par
  \tab ProviderQueryGetDataSetProperties(Sender: TObject; \par
  \tab DataSet: TDataSet; out Properties: OleVariant); \par
\tab begin \par
  \tab\tab Properties := VarArrayCreate([0,1], varVariant); \par
  \tab\tab Properties[0] := VarArrayOf(['Time', Now, True]); \par
  \tab\tab Properties[1] := VarArrayOf([ \par
    \tab\tab 'Param', SQLWithParams.Params[0].AsString, False]); \par
\tab end; \par
\par
\tab Unutmamak gerekir ki, variant t\'fcr\'fcnde dizi parametrelerinin kullan\'fdm\'fd hala \'e7al\'fd\'femakla birlikte DataSnap 2009 teknolojisi ile ula\'fe\'fdm\'fd art\'fdk farkl\'fdd\'fdr. \'ddstemci taraf\'fdnda, btnParamClick olay tetiklemesine fazladan 2 sat\'fdr daha kod yazarak ekstra bilginin d\'f6nen paketle birlikte gelmesini sa\'f0layabiliriz.\par
\par
\tab  Caption := 'Data sent at ' + TimeToStr ( \par
    \tab TDateTime (cdsQuery.GetOptionalParam('Time'))); \par
  \tab Label1.Caption := 'Param ' + \par
    \tab cdsQuery.GetOptionalParam('Param');\par
\par
\tab Eski versiyondan DataSnap 2009 yap\'fds\'fdn\'fd ge\'e7irme yap\'fdl\'fdrken bir ka\'e7 \'f6zellik daha anlat\'fdlabilir, ama ThinPlus2009 program\'fd (Delphi 6'da yaz\'fdlan haline g\'f6re baya de\'f0i\'feti) benim ama\'e7lar\'fdm\'fd ger\'e7ekle\'fetirmem i\'e7in \'feu anda yeterlidir. Bu ama\'e7 ise, DataSnap'in g\'fcc\'fc ve COM tabanl\'fd bir uygulaman\'fdn bu teknolojiye ne kadar \'e7abuk g\'fcncellenebildi\'f0idir.\par
\par
 \par
\f3\fs22\par
}
 